/*
 * Copyright (C) 2007-2008 
 * 			Jan de Muijnck-Hughes <jfdm@st-andrews.ac.uk>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * See LICENSE.txt for details
 *
 */
package uk.ac.stand.cs.jfdm.cs4099.transform;

import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.LinkedList;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import nl.tue.win.riaca.openmath.io.OMDOMReader;
import nl.tue.win.riaca.openmath.lang.OMApplication;
import nl.tue.win.riaca.openmath.lang.OMInteger;
import nl.tue.win.riaca.openmath.lang.OMString;
import nl.tue.win.riaca.openmath.lang.OMSymbol;

import org.apache.log4j.Logger;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import uk.ac.stand.cs.jfdm.cs4099.grouptheory.IPermutation;
import uk.ac.stand.cs.jfdm.cs4099.grouptheory.impl.Permutation;
import uk.ac.stand.cs.jfdm.cs4099.io.InputFile;
import uk.ac.stand.cs.jfdm.cs4099.utils.Log;

/**
 * Transforms an output file generated by the <code>ResultsExporter</code>
 * class into the same format accepted by the <code>FileImporter</code> class.
 * 
 * @author jfdm
 * @version 1
 * 
 */
public class ResultsTransformer {

	/**
	 * Used to log various aspects of the objects operation.
	 */
	private Logger logger = Log.getLogger(ResultsTransformer.class.getName());
	/**
	 * Represents the result of the transformation.
	 */
	private InputFile file_to_save = null;
	/**
	 * The content dictionary name for permutation code information.
	 */
	private static final String CD_PCODE_INFO = "pcodeinfo";
	/**
	 * The content dictionary name for automorphism group information.
	 */
	private static final String CD_AUTO_GROUP_INFO = "autogroupinfo";
	/**
	 * The content dictionary name for a list.
	 */
	private static final String CD_PERMUTATIONS = "List";
	/**
	 * The size of the permutation.
	 */
	private int perm_size;
	/**
	 * The file name used to store the result of the transformation.
	 */
	private String file_to_save_name;
	/**
	 * The Hamming Distance of the permutation code.
	 */
	private int hamming_distance;
	/**
	 * The number of codewords found.
	 */
	private int no_codewords_found;

	/**
	 * Creates a new Results Transformer that transform an output file into an
	 * input file.
	 * 
	 * @param input
	 *            The file containing the results information.
	 * @param output
	 *            The file to contain the transformed results.
	 * @throws Exception
	 *             If an error in the extraction and saving process.
	 */
	public ResultsTransformer(String input, String output) throws Exception {
		logger.info("Creating new Results Transformer");
		this.file_to_save_name = output;
		file_to_save = new InputFile();
		NodeList information = this.getOMANodes(input);
		if (information != null) {
			parseFile(information);
		} else {
			throw new Exception("Error getting information");
		}
	}

	/**
	 * Creates a new Results Transformer that transform an output file into an
	 * input file.
	 * 
	 * @param input
	 *            The file containing the results information.
	 * @throws Exception
	 *             If an error in the extraction and saving process.
	 */
	public ResultsTransformer(String input) throws Exception {
		logger.info("Creating new Results Transformer");
		file_to_save = new InputFile();
		NodeList information = this.getOMANodes(input);
		if (information != null) {
			parseFile(information);
		} else {
			throw new Exception("Error getting information");
		}
	}

	/**
	 * Returns the Hamming Distance of the Permutation Code.
	 * 
	 * @return An <code>int</code>.
	 */
	public int getHammingDistanceUsed() {
		return hamming_distance;
	}

	/**
	 * Returns the number of codewords in the Permutation Code.
	 * 
	 * @return An <code>int</code>.
	 */
	public int getNumberCodeWords() {
		return no_codewords_found;
	}

	/**
	 * Returns the object that represents the new input file.
	 * 
	 * @return An Input File.
	 */
	public InputFile getInput() {
		return file_to_save;
	}

	/**
	 * Saves the inputfile.
	 * 
	 * @return The <code>PrintWriter</code> used to write the information.
	 */
	public PrintWriter save() {
		return file_to_save.save(file_to_save_name);
	}

	/**
	 * Extracts the results information from the results file.
	 * 
	 * @param oma_nodes
	 *            A List of OpenMath Applications that contain the results.
	 * @throws IOException
	 *             If there is an error in the extraction of the data.
	 */
	private void parseFile(NodeList oma_nodes) throws IOException {
		logger.info("Parsing Information");
		OMDOMReader reader = null;

		for (int i = 0; i < oma_nodes.getLength(); i++) {
			reader = new OMDOMReader(oma_nodes.item(i));
			OMApplication app = (OMApplication) reader.readObject();
			OMSymbol sym = (OMSymbol) app.getElementAt(0);

			if (sym.getName().equals(CD_PCODE_INFO)) {
				logger.info("Extracting Permutation Code Information");
				perm_size = ((OMInteger) app.getElementAt(2)).intValue();
				hamming_distance = ((OMInteger) app.getElementAt(4)).intValue();
				no_codewords_found = ((OMInteger) app.getElementAt(6))
						.intValue();
				file_to_save.setSize(perm_size);
			} else if (sym.getName().equals(CD_AUTO_GROUP_INFO)) {
				logger.info("Extracting Automorphism Group Information");
				file_to_save
						.setAuto_group_info(((OMString) app.getElementAt(2))
								.getString());
				file_to_save.setAuto_group_size(((OMInteger) app
						.getElementAt(4)).intValue());
				file_to_save.addGenerator(this
						.parsePermutationList((OMApplication) app
								.getElementAt(5)));

			} else if (sym.getName().equals(CD_PERMUTATIONS)) {
				logger.info("Extracting Representatives.");
				file_to_save.addPermutation(this.parsePermutationList(app));
			}
		}

	}

	/**
	 * Extracts a list of permutations from the OpenMath Application containing
	 * them.
	 * 
	 * @param list_of_perms
	 *            The OpenMath Application containing the permutations.
	 */
	private Collection<IPermutation> parsePermutationList(
			OMApplication list_of_perms) {
		logger.info("\tExtracting Permutations");
		Collection<IPermutation> perms = new LinkedList<IPermutation>();
		for (int i = 2; i < list_of_perms.getLength(); i++) {
			perms.add(getIPermutationFromOMA((OMApplication) list_of_perms
					.getElementAt(i)));
		}
		return perms;

	}

	/**
	 * Extracts the Permutation from the OpenMath Application containing the
	 * Permutation.
	 * 
	 * @param app
	 *            The app containing the permutation.
	 * @return A <code>IPermutation</code> containing the permutation.
	 */
	private IPermutation getIPermutationFromOMA(OMApplication app) {
		String[] perms = new String[perm_size];

		for (int i = 1; i < app.getLength(); i++) {
			OMInteger in = (OMInteger) app.getElementAt(i);
			perms[i - 1] = String.valueOf(in.intValue());
		}
		return new Permutation(perms);
	}

	/**
	 * Extracts the results information from the file. The information is
	 * separated into the following:
	 * <ul>
	 * <li>Permutation Code Information</li>
	 * <li>Automorphism Group Information (if present)</li>
	 * <li>The permutations them selves</li>
	 * </ul>
	 * 
	 * @param file
	 *            The file containing the results as an OpenMath file.
	 * @return A <code>NodeList</code> containing the information as OpenMath
	 *         Applications.
	 */
	private NodeList getOMANodes(String file) {
		try {
			logger.info("Reading In Input File");
			XPath xpath = XPathFactory.newInstance().newXPath();
			return (NodeList) xpath.evaluate("/OMOBJ/OMA", new InputSource(
					new FileReader(file)), XPathConstants.NODESET);
		} catch (Exception e) {
			logger.error("Error Reading in File", e);
			return null;
		}
	}
}
